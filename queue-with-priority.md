<h1>Очередь с приоритетом</h1>
<div align="justify">
Из названия следует что это некоторое обобщение очереди. Как вы помните, очередь - это естественная структура данных, 
в которой элемент добавляется в конец очереди. Когда нужно обработать очередной элемент мы обрабатываем
его из начала очереди, то есть раньше всего обрабатывается тот элемент, который раньше всего в эту очередь добавился. 
В очереди же с приоритетами у нас у каждого элемента есть свой приоритет. Когда мы добавляем элемент, у него есть в 
этот момент приоритет, который ему задаётся тем, кто его добавляет в эту очередь. А когда нам нужно обработать очередной
элемент мы обрабатываем элемент, у которого в текущей очереди приоритет максимален. Такая естественная 
потребность возникает во многих ситуациях. Например, у нас есть некоторый пул работ и мы эти работы достаём по одной, 
выполняем и прямо в процессе выполнения работ могут добавляться новые. У работ есть некоторый параметр 
"важности" или приоритеты. И каждый раз, когда мы закончили обрабатывать текущую задачу или работу, необходимо следующей 
обработать именно ту, которая самая важная. Более формально очередь с приоритетом - это абстрактный тип данных, который 
поддерживает следующие операции. Основные операции - это добавить элемент (<em>Insert(p)</em>) с заданным приоритетом и 
извлечь из очереди элемент (<em>ExtractMax(p)</em>) с максимальным приоритетом. Как правильно также 
поддерживаются следующие дополнительные операции. Во-первых, удалить <em>Remove(it)</em> элемент заданный итератором, 
который мы будем обозначать просто <em>it</em>. Также существует операция нахождения максимального приоритета - 
<em>GetMax()</em>. Она просто возвращает максимальный приоритет из элементов, лежащих в текущей очереди, не изменяя 
саму очередь, ничего не извлекая из неё. Наконец метод <em>ChangePriority(it, p)</em> изменяет приоритет элемента 
заданного оператором <em>it</em> на заданный приоритет <em>p</em>.
</div>
<div align="justify">
Приведём примеры несколько классических и хорошо известных алгоритмов, где используется очередь с 
приоритетами:
<ol>
<li> алгоритм Дейкстры, который ищет кратчайшие пути в графе.</li>
<li> алгоритм Прима, который очень похож на алгоритм Дейкстры, но решает другую задачу - построения минимального 
покрывающего дерева в графе.</li>
<li> алгоритм Хаффмана, который строит оптимальное беспрефиксное кодирование заданной строки.</li>
<li> алгоритм сортировки кучей.</li>
</ol>
На самом деле их очень много и происходит это потому что очередь с приоритетами — это очень естественная структура 
данных. Естественно обрабатывать задачи в порядке их важности. Эта "важность" может в 
процессе меняться. Именно поэтому надо непросто отсортировать задачи и обработать, а в каждый 
момент, когда нам нужно обработать новую задачу, мы вызываем метод <em>ExtractMax(p)</em>, с помощью которой и обрабатываем
новые задачи, то есть это такой аналог метода <em>PopFront()</em>. Если <em>PopFront()</em> просто выдаёт элемент, 
который раньше всего пришёл, то ExtractMax возвращает элемент с максимальным приоритетом.</div>
<div align="justify">
Давайте рассмотрим две простейшие или наивные реализации. Один из естественных способов — это просто использовать 
для хранения связанный список или массив. Мы храним все элементы в очереди просто в списке или в массиве никак 
особо не задумываясь о том как нам надо их расположить, чтобы побыстрее обрабатывать. Тогда добавление занимает 
константное время. При этом мы считаем, что у нас массив достаточного размера или что используем массив переменного 
размера, который в среднем будет работать за константное время. Но при этой реализации, чтобы найти 
элемент с максимальным приоритетом нам конечно придётся прочитать весь массив. Это займёт у нас время O от <em>n</em>, 
где <em>n</em> - это текущее количество элементов. То есть операция <em>ExtractMax()</em>, в такой ситуации у нас будет занимать линейное 
время, что не очень хорошо. Сразу приходит в голову идея, чтобы ускорить операцию <em>ExtractMax()</em>, давайте стараться 
поддерживать наш массив или список упорядоченным. Тогда конечно <em>ExtractMax()</em> будет занимать у нас константное время, 
но проблема теперь в том, что вставлять мы не сможем за константное время и нам придётся тратить линейное время просто 
на вставку. Давайте поймём почему. Предположим у нас есть массив и мы его храним упорядоченным, чтобы быстро извлекать
максимум. Когда приходит новый элемент, чтобы сохранить этот самый порядок, нам надо найти, во-первых, позицию для 
него. Это мы сможем сделать за логарифмическое время бинарным или двоичным поиском. После этого при вставке нового 
элемента, чтобы массив оставался непрерывной последовательностью элементов, нам надо будет сдвинуть все элементы справа
от него и на это уже потребуется линейное время. Мы помним, что с другой стороны вставлять в список мы можем гораздо 
быстрее. Если у нас есть двусвязный список, то вставить в середину элемент можно за константное время. Но если у нас 
есть список, который хранится необязательно непрерывным куском памяти, то мы не можем для него использовать двоичный 
поиск. Мы не можем просто взять и обратиться к его среднему элементу. Нам придётся для этого сканировать половину 
списка. Итак, есть такие две простые реализации. В каждой из них одна из операций занимает линейное время и нашей следующей
целью будет рассмотрение реализации очереди с приоритетом под названием двоичная куча или просто куча. Двоичная куча — 
это классический и тоже естественный способ реализовать очередь с приоритетами. Настолько естественный, что часто под 
очередью с приоритетом понимают просто кучу. Но в действительности очередь с приоритетами — это абстрактный тип данных, 
а куча — это способ реализации этого абстрактного типа данных.
</div>
<table>
<tr>
<td></td>
<td>Insert</td>
<td>ExtractMax</td>
</tr>
<tr>
<td>Массив/список</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Упорядоченный массив/список</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</table>