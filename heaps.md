<h1>Двоичные кучи</h1>
<div align="justify">
Куча - это один из самых естественных и распространенных способов реализации очереди с приоритетом. 
Двоичной, во-первых, а, во-вторых, макс-кучей называется двоичное дерево, в котором у каждой вершины 
либо 0, либо 1, либо 2 сына, в которой выполняется следующее свойство - значение в каждой вершине больше
либо равно значению во всех её детях. Здесь даётся определение макс-кучи как раз потому что мы требуем, 
чтобы значение было больше либо равно, чем значение в сыновьях. У мин-кучи, тогда надо будет требовать, чтобы 
значение было меньше либо равно. На рисунке 1, б показано двоичное дерево, в котором для каждого ребра выполняется
следующее: значение в родителе должно быть больше или равно, чем значение в сыне. Такое свойство должно 
выполняться для каждого ребра. Итак давайте посмотрим на пару примеров. Слева, на рисунке 1, а показано 
двоичное дерево, которое не является кучей. Как видите на четырех ребрах свойство макс-кучи не выполнено. 
Например, число 10 оно не больше или равно, чем 25. Оно просто меньше, чем 25, а число 5 меньше, чем 17. 
С другой стороны на рисунке 1, б показано двоичное дерево, которое является кучей. Рассмотрим основные 
операции с кучей.
<div align="center">
<img src="/images/heaps/image1.svg" alt="Пример кучи" />
<p>Рисунок 1 - Пример кучи</p>
</div>
</div>
<div align="justify">
На рисунке 2, а у нас показан пример кучи. Применим к ней основные операции. Самое простое, что можно сделать - это 
найти максимальное значение (<em>GetMax</em>). И по этому примеру и в целом понятно, что максимальный приоритет в такой куче хранится в 
её корне. Свойство, что на каждом ребре значение сверху больше либо равно чем значение снизу говорит нам, что когда мы
поднимаемся вверх по куче мы можем только увеличиваться и соответственно самое большое значение может храниться только 
в корне. Если это самое большое значение, то это не мешает ему быть где-нибудь ещё, например, у вершины 42 мог бы быть 
сын, у которого значение тоже было бы 42. Это ничему не противоречит, но тем не менее, то значение, которое в корне - оно 
самое большое. Соответственно операция <em>GetMax</em> в такой ситуации работает очень просто: оно просто возвращает значение, 
которое хранится в корне. Работает это всё за константное время.
</div>
<div align="center">
<img src="/images/heaps/image2.svg" alt="Пример кучи" />
<p>Рисунок 2 - Основные операции</p>
</div>
<div align="justify">
Следующая операция - это операция вставки (<em>Insert</em>). На рисунке 2, б, в, г описано как её реализовать. Надо подвесить к листу 
нашу новую вершину и дать ей просеяться вверх. Что значит просеяться вверх? Давайте приведём пример. Предположим, что 
нам надо добавить новый элемент с приоритетом 30. Во-первых, мы его подвешиваем куда-нибудь куда можно. Что значит 
куда можно? Нельзя подвесить к вершине, у которой уже есть два сына, а вершину, у которой есть не более двух 
сыновей, к ней подвесить можно. Давайте её подвесим к вершине 14. У неё появился новый сын с приоритетом 30 (рисунок 2, б). При 
этом само собой когда мы это сделали мы видим, что на ребре 14-30 теперь свойство кучи нарушается. Поэтому просто 
так подвесить и на этом закончить - не получится. Теперь нам надо дать элементу, что называется просеяться вверх 
или всплыть. Давайте заменим, что сейчас свойство кучи у нас нарушено ровно на одном ребре и это ребро - 14-30. 
Это важный инвариант, который мы сейчас с вами будем поддерживать. Обменяем эти вот вершины местами. Теперь у нас 
вершина 14 будет сыном, а вершина 30 - родителем (рисунок 2, в). Соответственно теперь на этом самом ребре свойство 
кучи выполнено. Оно конечно же могло нарушиться где-то в другом месте и к счастью такое место может быть только одно. 
Свойство кучи нарушено как раз на ребре, которое ведёт из вершины 30 в её родителя. Ну значит надо дать дальше всплывать 
элементу. Меняем местами вершины со значениями 29 и 30 (рисунок 2, г). Теперь на этом ребре всё хорошо. Что-то могло 
сломаться выше, но этого не произошло. То есть элемент всплыл до того места, до которого ему надо было всплыть. Свойство 
кучи соблюдается и видно на самом деле, что время работы такой процедуры будет пропорционально, будет не больше, чем 
высота дерева. То есть всплывать элементу надо будет никак не больше, чем высота этого всего дерева.
</div>
<div align="justify">
Следующая операция - извлечение максимума (<em>ExtractMax</em>). Для этого нужно обменять корень с листом и просеять вниз. Зачем 
нужна операция обмена с листом? Как можно вообще извлекать максимум из нашего дерева? Мы знаем, где находится этот 
максимум. Это вершина 42, корень нашего дерева и там записано значение 42 (самое большое). Можно было бы просто 
отрезать и вернуть его. Но при этом дерево разваливается на две части. То есть у 42 сейчас есть левое 
поддерево и правое поддерево. Что с этим делать - не понятно. С другой стороны, есть вершины, которые отрезать от 
дерева очень просто, ничего при этом не сломается. Это листья, у них нет никаких поддеревьев (сыновей). Чтобы извлечь 
максимум мы берём и заменяем максимум на какой-нибудь лист. Пусть это будет лист со значением 12 (рисунок 2, д). 
Далее мы запомним это самое значение 42, нам надо будет вернуть его в конце. Но перед этим давайте починим 
свойство кучи, которое как видно у нас сейчас нарушено. Свойство кучи может быть нарушено ровно в одной вершине. 
Что это значит? Это значит, что только одна вершина может быть меньше или равна одному из своих сыновей или меньше или равна обоим 
своим сыновьям, как в нашей ситуации. Нам нужно элемент 12 просеять вниз и мы можем просеять его налево, в левое поддерево 
либо в правое. Если подумать, то становится постепенно ясно, что удобнее менять его с тем элементом, который больше, а 
именно в данной ситуации с элементом 30. Ну предположим мы бы поменяли его с элементом 18 вместо этого. Тогда у нас 
по-прежнему была бы проблема, потому что 18 меньше 30. То есть в корне свойство не починилось бы. Если мы в корне 
заменим 12 на элемент 30, тогда всё починится в корне и более того у нас останется всего одно поддерево, а именно 
левое, в котором по-прежнему надо будет чинить это свойство. Итак, мы смотрим на элемент 12. Он меньше либо равен хотя 
бы одному из сыновей. Тогда мы смотрим на обоих сыновей, выбираем из них максимум. Максимум - это 30, мы меняем этот 
корень с элементом 30 (рисунок 2, е). Теперь смотрите что произошло. В корне всё хорошо. В правом поддереве корня всё как было 
хорошо, так хорошо и осталось. Единственная проблема, которая теперь где-то потенциально может быть - это в новой 
вершине, в той вершине, в которой сейчас после обмена лежит элемент 12. Там опять нарушено свойство кучи. Но что 
приятно, что у нас всего одна проблема, поэтому мы продолжаем это делать рекурсивно или в цикле. У элемента 12, 
есть сыновья 29 и 7. Меняем его с элементом 29 (рисунок 2, ж). Опять видим, что в вершине со значением 12 проблема. Её надо 
поменять с элементом 14 (рисунок 2, з). Всё, элемент 12, который был листом и стал в какой-то момент корнем, утопился опять до 
листа. Так не обязательно будет всегда. Но так или иначе мы восстановили свойства кучи, теперь оно везде выполнено и 
ясно, что время работы нашей процедуры, количество вот этих вот обменов, которое должно произойти не 
больше, чем высота дерева. Потому что каждый раз мы проблемную вершину утапливаем хотя бы на один уровень вниз.
</div>
<div align="justify">
Операция изменение приоритета (<em>ChangePriority</em>). Выбираем вершину, в которой нам надо изменить приоритет. Мы договорились, 
что задаваться она будет каким-то указателем, итератором или ссылкой на неё. Меняем приоритет, а потом в зависимости от 
того увеличился приоритет или уменьшился, нам надо запустить нашу внутреннюю вспомогательную процедуру просеивания 
либо вниз, либо вверх в зависимости от того увеличился он или уменьшился. Работать это всё будет время не больше, чем 
О от высоты дерева.
</div>
<div align="justify">
Наконец, последняя операция - <em>Remove</em>, как удалять из кучи элемент. Предположим, что нам надо удалить некоторый 
элемент. Давайте изменим приоритет элемента, который нужно удалить на плюс бесконечность, ну или другими словами на 
какое-то значение, которое уж заведомо больше, чем все значения в нашей куче. Ну, например, на значение <em>GetMax</em>+1. 
После этого сама даже процедура <em>ChangePriority</em> даст этому элементу всплыть до корня. То есть он теперь больше, чем все 
остальные элементы, соответственно он всплывёт или просеется вверх до корня. А после этого мы можем просто вызвать 
процедуру <em>ExtractMax</em>. Соответственно <em>Remove</em> можно так просто и реализовать, вызовом двух уже имеющихся 
у нас процедур.
</div>
<div align="justify">
Подводим итоги. Когда задано такое представление кучи (двоичной кучи, двоичной макс-кучи) в виде двоичного дерева, 
то мы без труда можем реализовать все операции там, чтобы они работали за время не больше, чем О от высоты дерева. 
Более того операция <em>GetMax</em> на самом деле будет работать конечно же за константное время, потому что всё что ей нужно - это 
посмотреть на корень. Наша цель в последующих лекциях будет, будет состоять в том, чтобы гарантировать, что это 
дерево, которое у нас имеется всегда будет не очень высоким. То есть мы постараемся поддерживать наше дерево не высоким 
и не дадим ему высоко разрастись.
</div>