<h1>Очередь</h1>
<div align="justify">
Следующая простая структура данных, которую мы рассмотрим, называется очередь. 
Очередь представляет собой последовательность элементов
и когда нам нужно добавить новый элемент мы добавляем элемент в конец очереди, когда нам нужно обработать (обслужить) 
новый элемент, мы делаем это из начала очереди. По этой причине эта абстрактная структура данных или абстрактный тип 
данных называется типом данных типа FIFO (First In First Out). Начало и конец очереди называются Back и Front. 
Обслуживается первым тот элемент, который первым в эту очередь поступил. Описывается этот тип данных такими 
операциями:
</div>
<ol>
<li><code>Enqueue (PushBack)</code> - это операция, которая добавляет элемент в конец очереди как следует из названия.</li>
<li><code>Dequeue (PopFront)</code> - извлекает элемент из очереди.</li>
<li><code>IsEmpty (Empty)</code> - проверяет пустая очередь или нет.</li>
<li><code>Size</code> - возвращает размер нашей текущей очереди, то есть количество элементов.</li>
</ol>
<div align="justify">
Реализовывать очередь, так же как и стек, можно с помощью массива или с помощью односвязного списка 
и так, что каждая из заявленных операций будет работать за константное время. С помощью массива можно это делать 
следующим образом. Во-первых поскольку опять используется массив - это означает, что заранее у нас будет 
фиксированный размер очереди и если мы попытаемся добавить в очередь очередной элемент, а при этом текущий массив 
весь заполнен придется выдавать сообщение об ошибке или увеличивать размер массива. 
Сейчас давайте для простоты считать что массив фиксированный, что означает, что у нас есть некая верхняя оценка 
на количество элементов, которые мы можем хранить в очереди. Итак тогда очередь внутри массива будет занимать 
такой непрерывный кусок элементов и мы будем помнить индекс начала этого элемента, front и индекс конца - это back 
(рисунок 1, а). Когда нам надо извлечь элемент из начала очереди, мы просто сдвигаем указатель или индекс front на 
единичку вперед, и заодно возвращаем его значение. Когда нам надо добавить в конец элемент, мы делаем это
следующим образом. Мы добавляем элемент в конец, а после этого говорим, что теперь back, это может быть 
указатель или просто индекс в этом массиве, указывает на последний элемент (рисунок 1, б). Здесь сознательно сделано 
так, чтобы мы подошли к границе, чтобы показать, что когда следующий элемент будем добавляться в очередь, то мы его 
добавим в начало. Таким образом, массив мы себе представляем замкнутым, закольцованным. Другими словами, удобно
просто брать индексы по модулю размера массива. То есть если этот массив у нас размера <em>n</em>, 
другими словами его индексы - это числа от нуля до <em>n</em>-1, то когда мы находились в ячейке с индексом <em>n</em>-1 мы 
прибавляем к ней единицу, но при этом берем по модулю <em>n</em> (по модулю размера массива) получаем индекс 0. Вот так
соответственно он и зациклится и будет довольно простая реализация. Операции определения размера, извлечения и 
работают за время О(<em>1</em>).</div>
<img src="/images/queue/image1.png" alt="реализация очереди с помощью массива" />
<p>Рисунок 1 - Реализация очереди с помощью массива</p>
<div align="justify">
С помощью списка также просто реализовать очередь. Мы храним список и помним где у него голова, где у него хвост.
Если нам надо извлечь элемент из очереди, берём первый элемент и говорим, что
теперь голова нашего списка должна указывать на второй (рисунок 2, а). Если нам надо добавить в конец, мы добавляем 
и говорим что теперь изменился указатель на tail (рисунок 2, б).</div>
<img src="/images/queue/image2.png" alt="реализация очереди с помощью списка" />
<p>Рисунок 2 - Реализация очереди с помощью списка</p>
<div align="justify">
Теперь давайте рассмотрим ещё одну реализацию очереди с помощью двух стеков. Давайте представим себе два стека, которые 
теперь расположены горизонтально, причем нижними частями они друг к другу как бы прислонены. Один стек (левый) 
называется у нас схематично "Добавляем", а второй стек - "Извлекаем". Проще всего на примере объяснить как это 
работает. Представим, что мы будем добавлять элементы в очередь, причем с возрастающими номерами,
1, 2, 3, 4, 5, 6. Пусть сначала нас попросили добавить четыре элемента. Мы добавляем их как следует из названия 
просто в левый стек. Итого мы положили сначала элемент 1, потом 2, 3, 4 (рисунок 3, а). Предположим, что теперь 
пришёл запрос на обработку элементов, то есть вызвали метод <code>PopFront()</code>. Во-первых, мы знаем, что обслужить надо 
тот элемент первым, который был добавлен в нашу очередь первым. Но он у нас сейчас лежит в самом низу нашего 
левого стека, а в самом вверху лежит элемент 4, который сейчас нам обслуживать не надо. Сделаем вот что. Раз правый стек,
из которого мы собираемся извлекать, пуст, возьмём и все элементы из левого стека 
переложим в правый стек. Мы вытащим четверку и положим её в правый стек, потом тройку, двойку, единицу, но на самом 
деле поскольку было вызван <code>PopFront()</code> нам её надо отдать. И вот здесь мы её выдаём (рисунок 3, б). То есть все 
элементы переложились из левого стека в правый стек, при этом порядок у них теперь такой, как нам нужен. Предположим, 
что теперь был вызван метод <code>PushBack()</code> c ключом 5. Тогда пять добавится в левый стек и всё. После этого вызвался
<code>PopFront()</code>. Мы при этом достали двойку. Действительно мы видим, что когда вызывается <code>PopFront()</code>
элементы обрабатываются в том порядке, в котором нужно. Несложно видеть, что так они и будут обрабатываться в нужном порядке. Что когда мы 
перекладываем из одного стека в другой, то в правом стеке порядок образуется ровно тот, который нам нужен. 
Плохо в этой реализации только вот что. Мы не можем сказать что каждая операция здесь занимает константное время.
Предположим, что мы сначала <em>n</em> раз вызвали метод PushBack(), то есть положить в нашу очередь. Тогда все элементы 
добавятся в наш левый стек. И это занимало конечно константное время. Но потом предположим мы вызываем <code>PopFront()</code>. 
Для этого нам все <em>n</em> элементов из левого стека придётся переложить в правый стек. Мы будем делать это долго,
за время О(<em>n</em>). И только потом мы сможем выдать тот самый первый элемент. То есть гарантировать здесь 
константную оценку на время работы в худшем случае мы не можем. Но зато мы можем сказать, что в среднем каждая 
операция здесь работает за константное время. Другими словами, амортизированное время каждой работы здесь — это 
О(<em>1</em>). Чтобы чуть более формально это сказать, сформулируем такое утверждение. Представим что у нас вот 
таким вот образом реализована очередь. Реализована она на базе двух стеков. Работают операции так. Когда приходит
запрос на то, чтобы добавить элемент в очередь, мы просто помещаем его в левый стек. Когда нужно извлечь элемент 
из очереди, если правый стек не пуст, тогда мы извлекаем просто его верхушку. Если правый стек пуст, тогда сначала
весь левый стек перекладываем в правый по одному элементу. Представим, что с нашей очередью 
проведено 2(<em>n</em>) операций. В какой-то последовательности в неё были помещены (<em>n</em>) элементов и все они были потом 
извлечены. Для простоты давайте считать, что мы начали с пустой очереди и закончили с пустой очередью. А в процессе в
каком-то порядке произошли (<em>n</em>) операций. То есть добавились <em>n</em> элементов в нашу очередь и все они потом были
обработаны. Мы не знаем в каком порядке это произошло. Возможно они сначала все (<em>n</em>) были добавлены, потом 
все (<em>n</em>) были извлечены. Возможно мы сначала 10 добавили, потом два извлекли, потом три добавили, ну и так
далее. Порядок не важен. Утверждение такое: в любом случае суммарное время работы всех этих операций при такой 
реализации будет равно О(<em>n</em>). Почему это так понять на самом деле не очень сложно. Давайте просто проследим 
за тем вкладом во время работы, который даёт каждый из наших элементов. Тут я хочу сказать что это время работы, этот 
вклад каждого элемента — он константный. Ну действительно давайте поймём что происходит с каждым отдельным из 
наших (<em>n</em>) элементов. Его один раз поместят в левый стек и случится это когда он будет добавлен в очередь. 
Это произойдет за константное время. Дальше во время одного из вызовов <code>PopFront()</code>, то есть обработки элемента этот 
элемент переедет из левого стека в правый. Это тоже произойдет за константное время поскольку мы сейчас следим только 
за этим элементом. И потом в какой-то момент его извлекут. То есть каждый элемент в суммарное время 
работы даёт вклад три. Его добавили, его перенесли из одного стека в другой и его вытащили. Просто это время работы, 
будет размазано по нашим 2<em>n</em> операциям, из которых <em>n</em> - это добавление и <em>n</em> извлечение. Мы не можем 
сказать, что каждая из этих 2<em>n</em> операций займет константное время работы, но 
суммарно время работы всех операций будет равно где-то 3<em>n</em> или О(<em>n</em>). При этом получается, что в 
среднем время работы одной операции будет константным.</div>
<img src="/images/queue/image3.png" alt="реализация очереди с помощью двух стеков" />
<p>Рисунок 3 - Реализация очереди с помощью двух стеков</p>
<div align="justify">
С помощью этих трюков мы научились решать следующую задачу. 
Представим, что нам дана последовательность из <em>n</em> элементов. Мы хотим пройтись по этой последовательности скользящим 
окном размера <em>m</em>, и для каждого такого окна напечатать минимум. Пусть дана последовательность какой-то длины (рисунок 4) 
и m равно 3. То есть первое окно размера три — пять, один, три. В нём минимум это единица. 
Дальше мы наше окно сдвигаем, получается вот такое — один, три, два. В нём минимум тоже единица. То есть здесь 
каждый элемент в нижнем массиве — это минимум в окне, у которого правая граница расположена над ним. Следующее будет окно — три,
два, четыре - в нём минимум два. И так далее. Давайте подумаем за сколько можно эту задачу было бы решить 
в лоб — за О<em>n</em> умножить на m. Окон <em>n</em>-<em>m</em>+1, ну или если грубо, то там их О(<em>n</em>) и если в каждом 
окне честно искать минимум, то получится О(<em>n</em>) умножить на m. Но в действительности эту задачу можно решить за 
<em>n</em>+<em>m</em> и на самом деле решение Вы уже знаете. Вам осталось только его осознать. Это не единственный способ, 
то есть с использованием наших простых структур данных, которые мы рассмотрели, можно эту задачу решить гораздо 
эффективнее, чем решением в лоб. Таким образом, перейти от <em>n</em> * <em>m</em> к <em>n</em> + <em>m</em>. Что в свою очередь будет равно О(<em>n</em>), 
потому что <em>m</em> конечно должно быть не больше, чем <em>n</em>. Потом можете за одно придумать
способ решить эту задачу за О(<em>n</em>+<em>m</em>) и без использования таких структур данных, а какими-нибудь 
другими методами.
</div>
<img src="/images/queue/image4.png" alt="пример последовательности" />
<p>Рисунок 4 - Пример последовательности</p>