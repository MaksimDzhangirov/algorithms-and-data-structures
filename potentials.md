<h1>Метод потенциалов</h1>
<div align="justify">
C помощью метода потенциалов мы ещё раз докажем, что мультипликативная схема перевыделения памяти при работе с
массивами переменного размера гарантирует, что при добавлении туда n элементов будет потрачено суммарно линейное время 
O(<em>n</em>). Итак рассмотрим некоторую структуру данных, природа которой нам сейчас не важна. Предположим, что с ней 
совершаются подряд n операций, которые мы так и обозначим op<sub>1</sub>, op<sub>2</sub> и так далее op<sub>n</sub>. 
Предположим также, что изначально состояние нашей структуры данных это s<sub>0</sub>. Это просто обозначение для 
нашей структуры данных. При применении операции op<sub>1</sub> мы переходим в состояние s<sub>1</sub>, дальше 
в состояние s<sub>2</sub> и так далее. Опять же это просто обозначение. Давайте считать, что c<sub>i</sub> - это 
стоимость <em>i</em>-той операции или просто время работы <em>i</em>-той операции. Иногда стоимость также 
называют ещё истинной стоимостью и наконец давайте через &phi;<sub>i</sub> обозначим некоторый потенциал состояния
структуры данных. Это просто некоторое число которое как-то зависит от того, что происходит внутри нашей 
структуры данных, от количества элементов в ней, от того как они расположены или ещё чего-то. Сейчас природа 
этого не важна. Таким образом, &phi;<sub>i</sub> - это просто потенциал, число, связанное с состоянием структуры 
данных, а c<sub>i</sub> - это истинная стоимость <em>i</em>-той операции. Введём учетные стоимости каждой из 
операций. Обозначать мы будем их c'<sub>i</sub> и по определению они равны сумме истинной стоимости, то есть 
c<sub>i</sub> и тому на сколько изменился потенциал, то есть &phi;<sub>i</sub> минус &phi;<sub>i-1</sub>. 
После того как мы всё это ввели, можно вывести такую формулу, которая здесь написана на рисунке 1.
Сумма c<sub>i</sub>, то есть сумма истинных стоимостей по i от 1 до n равна сумме учётных стоимостей, то есть 
сумме c'<sub>i</sub> от i равно от 1 до n плюс &phi;<sub>0</sub> минус &phi;<sub>n</sub>, то есть плюс начальный 
потенциал минус конечный потенциал. Почему это так? Распишем сумму c'<sub>i</sub>. c'<sub>1</sub> - это 
с<sub>1</sub> плюс &phi;<sub>1</sub> минус &phi;<sub>0</sub>. c'<sub>2</sub> - c<sub>2</sub> плюс 
&phi;<sub>2</sub> минус &phi;<sub>1</sub>. Если мы начнём всё это складывать, то почти все потенциалы, каждый 
из них войдет в сумму один раз с плюсом, один раз с минусом и все промежуточные потенциалы посокращаются. Останется 
просто &phi;<sub>n</sub> и &phi;<sub>0</sub> с другими знаками. Перенеся разность потенциалов 
влево у нас получится как раз сумма c<sub>i</sub>, то есть сумма истинных стоимостей.
<div align="center">
<img src="/images/potentials/image1.svg" alt="Метод потенциалов" />
<p>Рисунок 1 - Метод потенциалов</p>
</div>
</div>
<div align="justify">
Если правильным образом подобрать потенциал, что на самом деле бывает не так и просто, тогда может оказаться, что 
сумму c'<sub>i</sub> оценивать гораздо проще. Например, в нашей ситуации с мультипликативной схемой 
перевыделения c<sub>i</sub> - это стоимость каждой i-той операции. Но мы помним, что каждая из них сильно 
зависит от того произошло ли перевыделение в момент добавления нового элемента или нет. Если добавление происходит 
просто в текущую существующую ячейку и перевыделения никакого не происходит, то всё просто. Тогда c<sub>i</sub> 
просто равно единице. Но если происходит перевыполнение, то к сожалению мы даже заранее не можем оценить сколько 
времени оно займет, потому что это зависит от того сколько там элементов. Таким образом бывают некоторые операции, 
которые занимают единицу, а бывают некоторые операции, которые занимают какое-то время, зависящее от текущего 
количества элементов. Здесь мы сделаем так, что все эти c<sub>i</sub> с помощью специально подобранного потенциала
переделаем в c'<sub>i</sub>, которые как раз окажутся константными. После чего у нас получится опять та же 
оценка. Введенный формализм в дальнейшем окажется очень полезным.
</div>
<div align="justify">
Давайте в нашей схеме мультипликативного перевыделения считать, что наша константа &alpha; равна двум. 
Так будет проще, чтобы не использовать константы типа 1,5 или золотого сечения. Конечно же этот анализ можно будет 
проделать и для любой другой константы. Давайте введём ещё два обозначения.Через <em>l</em> как обычно будем обозначать 
размер нашего массива в текущий момент. Это просто количество ячеек, а через <em>s</em> - количество занятых ячеек. 
Тогда потенциалом текущего состояния структуры данных мы назовём число равное 2 <em>s</em> минус <em>l</em>. 
На рисунке 2 чуть лучше было бы написать, что &phi;<sub>i</sub> равняется 2 s<sub>i</sub> минус 
l<sub>i</sub>, где s<sub>i</sub> - текущее количество элементов на i-том шаге, l<sub>i</sub> - текущий размер. Не будем
за собой таскать эти индексы и надеюсь, что и без них всё будет понятно. Давайте теперь смотреть чему же будут 
равны в нашей ситуации учётные стоимости всех операций. Напомним ещё раз, что каждая операция - это просто добавление 
элементов в конец нашего массива. Но добавление может вызвать перевыделение памяти, а может не вызвать. Если 
перевыделения не происходит, то всё проще. Тогда изменяются параметры s и l. s увеличивается на единицу, а l остаётся 
таким же каким оно и было. c<sub>i</sub>, то есть истинная стоимость операции в данном ситуации равна единице. 
Положить в ячейку какой-то элемент - это одна условная единица, в них мы будем всё измерять. Давайте смотреть тогда 
чему равна будет учётная стоимость в данной ситуации. То есть сейчас посчитаем c'<sub>i</sub>. 
Итак это истинная стоимость, то есть единица плюс то на сколько изменился потенциал. 
Новый потенциал равен 2 (s + 1) - l. Старый потенциал - 2s - l. Видно, что 2s и l здесь сокращаются. Всё что осталось - 
это единичка и двоечка из первой скобки. То есть итого 3 (рисунок 2). Стоит заметить, что здесь учётная стоимость 
чуть больше истинной стоимости. Вместо того, чтобы быть равной единице, она равна тройке, то есть мы зачем-то как 
будто бы накапливаем кое-что во время таких вот добавлений без перевыделений.</div>
<div align="justify">
Давайте теперь рассмотрим более интересный случай добавления с перевыделением. В этой ситуации у нас s равно l, то 
есть количество заполненных элементов стало равным просто общему количеству элементов. s у нас всё время 
на самом деле меняется на единицу, то есть новое s у нас равно s+1, а l в нашей ситуации увеличилась в два раза и 
l перешло в 2l. Истинная стоимость операции у нас в данной ситуации равна l+1, потому что нам надо скопировать сначала 
l текущих элементов, а потом ещё один элемент добавить. Теперь давайте вычислять чему равна учётная стоимость такой 
операции. Во-первых, она равна истинной стоимости (l+1), во-вторых, равна тому каким стал равен потенциал. Это 2(l+1) 
минус текущий размер массива, а он у нас стал равным 2l. Итак, это 2(l+1) минус 2l. Видно что потенциал на самом деле
упал, он сейчас у нас очень маленький. Это просто 2. С другой стороны то каким потенциал был это 2l минус l, потому 
что s у нас равняется l. Видим, что все l здесь сократились, всё что осталось это вот единичка из истинной стоимости и 
двоечка из первой скобки. Результат опять равен тройке. Давайте теперь ещё раз вспомним нашу формулу. 
Сумма c<sub>i</sub>, вот она написана снизу равна сумма c'<sub>i</sub> плюс &phi;<sub>0</sub> минус &phi;<sub>n</sub>. 
Мы помним, что сумму c<sub>i</sub> оценивать не очень просто в том смысле, что разные c<sub>i</sub> имели разные 
значения, причём, если бы мы совсем загрубили и сказали что каждый c<sub>i</sub> ну явно не больше чем 
время n занимает, то всё что мы могли бы сказать, что сумма c<sub>i</sub> не больше, чем n в квадрате. Но это было 
бы слишком грубо. Мы знаем, что эта сумма ограничена на самом деле линейной функцией. Но теперь мы видим, что сумму
c<sub>i</sub> со штрихами оценить очень просто. Каждый из них просто равен тройке. Соответственно сумма это у нас
ничто иное как 3n, ну и плюс ещё добавка &phi;<sub>0</sub> минус &phi;<sub>n</sub>, про которую тоже на самом деле 
понятно, что она не большая.</div>
<div align="justify">
<p>В начальный момент s = 0, l = 0, &phi;<sub>0</sub> = 0.</p>
<p>Непосредственно *после* перевыделения, s = l, l = 2l, &phi;<sub>n</sub> = 0.</p>
<p>Непосредственно *перед* перевыделением, s = l, l = l, &phi;<sub>n</sub> = l.</p>
<p>Отсюда можно сделать вывод, что разность потенциалов не будет больше текущего размера массива.</p>
<p>Таким образом, суммарно мы потратим время &Theta; от n. В дальнейшем мы будем использовать 
метод потенциалов при анализе более сложных структур данных.</p>
<div align="center">
<img src="/images/potentials/image2.svg" alt="Расчёт учётной стоимости" />
<p>Рисунок 2 - Расчёт учётной стоимости</p>
</div>
</div>
<div align="justify">
Наконец, приведём графики истинных и учетных стоимостей (рисунок 3). Почти всё время 
истинные стоимости операций добавления равны единице. И это соответствует нижней линии 
с точками. Но периодически случаются вот такие вот скачки. То есть то нам понадобилось выделить массив, скопировать 
два элемента, потом четыре, потом восемь и так далее. Это всё делает не очень удобным оценку суммы 
c<sub>i</sub>. Но специально подобранным потенциалом мы сумели добиться того, чтобы 
каждая учётная стоимость нашей операции равнялась просто трём. Соответственно её оказалось гораздо проще 
оценивать. Нам надо было отдельно ещё гарантировать, что сумма &phi;<sub>0</sub> минус &phi;<sub>n</sub> 
не даст какого-то существенного вклада, но это как правило не сложно и в нашей ситуации так 
и есть.
<div align="center">
<img src="/images/potentials/image3.svg" alt="График истинных и учётных стоимостей" />
<p>Рисунок 3 - График истинных и учётных стоимостей</p>
</div>
</div>