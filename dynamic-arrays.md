<h1>Массивы переменного размера</h1>
<div align="justify">
Рассмотрим следующую ситуацию. Мы хотим работать с массивом, то есть иметь константный доступ по индексу, но мы заранее
не знаем его размер. Таким образом, мы заранее не знаем размер последовательности, которую мы собираемся там хранить. В такой 
ситуации пока у нас наш текущий размер массива позволяет добавлять туда элементы, мы добавляем их в конец. В тот 
момент, когда мы пытаемся добавить элемент в конец массива, но пониманием, что текущий массив уже заполнен, мы делаем 
следующее: выделяем новый объём памяти, который содержит больше ячеек, чем нас текущий массив, копируем туда всё что 
лежит в нашем текущем массиве и в новую ячейку, которая идёт сразу после последнего скопированного элемента, 
добавляем новый элемент. Тем самым мы получаем новый массив, мы по-прежнему можем с ним работать как с массивом и у 
нас даже есть ещё сколько-то свободных ячеек. Вопрос здесь основной в том как же именно менять размер текущего массива,
который мы будем обозначать буквой <em>l</em> при этом самом выделении. То есть во сколько или на сколько нужно его увеличивать 
(рисунок 1). Это соответствует двум естественным схемам, так называемым схемам перевыделения памяти: мультипликативной 
(увеличение в несколько раз) или аддитивной (увеличение на какое-то константное количество ячеек размера текущего 
массива). Определим какая из этих схем перевыделения или релокации лучше.
<div align="center">
<img src="/images/dynamic-arrays/image1.svg" alt="Перевыделение памяти для массива переменного размера" />
<p>Рисунок 1 - Перевыделение памяти для массива переменного размера</p>
</div>
</div>
<div align="justify">
В случае аддитивной схемы перевыделения текущий размер массива <em>l</em> увеличивается на константу, которую мы будем 
обозначать &Delta;. Так от <em>l</em> мы переходим к <em>l</em> плюс &Delta;. Для мультипликативной схемы перевыделения
мы текущий размер массива <em>l</em> увеличиваем в определенное число раз, больше единицы. Мы будем её обозначать 
буквой &alpha;. Давайте поймём теперь сколько времени у нас будет работать та и другая реализация такого массива 
переменного размера. Время мы будем оценивать относительно количества элементов, которые добавим в такой массив. То 
есть в процессе нашей работы могут случаться какие-то обращения к элементам по индексу, их сейчас мы учитывать не будем. 
Нас будет интересовать суммарное время, которое мы потратим на то, чтобы скопировать элементы при перевыделении.
</div>
<div align="justify">
Итак, начнём с аддитивной схемы. Давайте для простоты считать, что мы начали с массива вообще нулевого размера (l равно нулю). 
Тогда, когда мы попытались в него что-то положить, мы увеличили его до размера &Delta;. После этого мы добавляем туда 
элементы, это всё происходит очень быстро, поскольку мы просто добавляем в конец, но когда нам понадобилось добавить &Delta; 
плюс один элемент нам придётся всё перевыделить и определить массив размера два &Delta;. Мы скопируем туда &delta; 
элементов, то есть уже потратим на эту операцию добавления какое-то существенное число элементов. Когда число наших 
элементов превысило уже 2 &Delta; впервые, нам пришлось сделать массив размера 3 &Delta; и наши текущие 2 &Delta; 
элементов туда скопируются. И так далее, то есть мы будем так продолжать и в какой-то момент всё это у нас закончится 
слагаемым k &Delta; (рисунок 2). k &Delta; - это примерно текущее число элементов n, которое не обязано делится 
на &Delta; нацело, но примерно оно ему равно. Это округление на асимптотику здесь не повлияет. Сумма - это 
арифметическая прогрессия. Давайте &Delta; вынесем, тогда всё что у нас останется - это один плюс два плюс и так далее k. 
Получаем &Delta; на 1/2 на k на k + 1. Вспомним, что k - это примерно n/&Delta;, то сумма примерно равна k в квадрате
поделить на &Delta;, ну а k на самом деле то же самое, что и n с точностью до этой константы &Delta;. 
Соответственно суммарное время, которое мы потратили оно с ростом <em>n</em> растёт квадратично. То есть это &Theta; 
от <em>n</em><sup>2</sup>. И как мы сейчас увидим сравнив с мультипликативной схемой реалокации это вообще-то не так и 
мало. То есть мультипликативная схема реалокации позволяет сделать всё то же самое, потратив суммарно на все 
перевыделения время всего лишь линейное от n. Давайте анализировать. Итак мы наш массив договорились увеличивать каждый 
раз при перевыделении в &alpha; раз. В этой ситуации разумно начать конечно с массива размера не ноль, а один, иначе 
он всё время будет у нас равен нулю. Давайте опять для простоты считать, что мы начали с массива размера один, потом 
сделали его размера &alpha;, в следующий раз мы его сделаем размера &alpha;<sup>2</sup>. В результате получим сумму
в виде геометрической прогрессии. Опять таки последний член этой суммы - это на самом деле примерно с точностью до 
множителя &alpha; наше число элементов, но это на нашу асимптотику не повлияет. Действительно n 
не обязано быть равно &alpha;<sup>k</sup>, не обязано даже на константу отличаться от него, но оно не больше, чем 
в &alpha; раз отличается, поскольку мы говорили, что &alpha; константа. Таким образом, можно сказать, что 
&alpha;<sup>k</sup> - это примерно n. Про геометрическую прогрессию опять мы знаем что, когда в геометрической прогрессии 
коэффициент &alpha; больше единицы, тогда её сумма растёт просто как последний член. Но для этой конкретной суммы можно
написать просто равенство &alpha;<sup>k+1</sup>-1 делённое на &alpha; - 1. Это равенство верно в предположении, что 
&alpha; не равно 1. Что верно в нашем случае, поскольку мы хотим увеличивать размер массива. Ну и это 
просто &Theta; от n. Деление на &alpha;-1 - это просто деление на некоторую константу. Поэтому про него можно забыть, 
про вычитание единицы тем более. Ну а &alpha;<sup>k+1</sup> оно всего в &alpha; раз отличается от &alpha;<sup>k</sup> и 
&alpha; - это константа. &alpha;<sup>k</sup> - это n, поэтому оценка равна &Theta; от n. Соответственно &Theta; от n 
конечно же гораздо лучше, чем &Theta; от n<sup>2</sup>. Из чего мы делаем вывод, что мультипликативная схема 
реалокации - это правильный способ, а вот аддитивная - не самый правильный (рисунок 2).
<div align="center">
<img src="/images/dynamic-arrays/image2.svg" alt="Аддитивная и мультипликативная схема перевыделения" />
<p>Рисунок 2 - Аддитивная и мультипликативная схема перевыделения</p>
</div>
</div>
<div align="justify">
Действительно, например, в реализации вектора библиотеки C++ используется именно мультипликативная схема реалокации с 
некоторой константой &alpha;, которая равна где-то в районе 1,5. Вообще её можно выбирать из каких-то евристических 
наблюдений. На практике берут либо 1,5, либо золотое сечение. В следующий раз мы докажем, что мультипликативная схема 
реалокации действительно даёт линейную оценку на время работы слегка другим методом, так называемым методом потенциалов,
который окажется очень полезным в дальнейшем.
</div>