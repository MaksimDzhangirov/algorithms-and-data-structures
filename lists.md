<h1>Списки</h1>
<div align="justify">
Cписок, как и массив - линейная структура данных.
</div>
<div align="justify">
Но в отличие от массива элементы в списке не обязаны идти друг за другом 
прямо непосредственно в памяти. Они могут располагаться где угодно. За счет этого  
список не обязан иметь фиксированный размер. С другой стороны, за это приходится 
платить тем, что нужно хранить не только сами элементы, но и ссылку на следующий элемент.
</div>
<div align="justify">
<p>В общем случае список выглядит как показано на рисунке 1. Здесь каждый элемент - это на самом деле пара: 
данные плюс указатель на следующий элемент. Для простоты опять будем считать что наши данные, 
которые мы иногда будем называть просто ключами - это просто числа.</p>
<img src="images/lists/image1.svg" alt="Односвязный список" />
<p>Рисунок 1 - Односвязный список</p>
<p>На рисунке показан односвязаный список,
односвязный, потому что в каждом элементе хранится одна связь, один указатель или одна ссылка на следующий 
элемент. Мы также помним указатель на голову (Head) списка. Дальше идет первый элемент у него ключ 2 и он
помнит указатель на следующий элемент, который хранится где-то возможно в совершенно другом месте в памяти.
Следующий элемент за пятым - семь и так далее. У последнего элемент указатель нулевой или указатель на 
null или на nil. Также мы можем хранить указатель, который называется Tail, то есть на хвост списка. 
Иногда нам может понадобиться знать, где располагается последний элемент списка. Это зависит от того как 
именно мы собираемся работать с нашим списком. Удобно тот же самый список изображать 
как показано на рисунке 2. То есть будем просто считать, что элементы идут друг за другом.</p>
<img src="/images/lists/image2.svg" alt="Односвязный список, элементы изображены друг за другом" />
<p>Рисунок 2 - Односвязный список, элементы изображены друг за другом</p>
<p>Каждый элемент списка - это такая небольшая структура данных, в которой, во-первых, хранятся данные произвольной 
природы, а, во-вторых, указатель на следующий элемент. Здесь изображен односвязный список, потому что 
каждый элемент хранит ровно одну связь - указатель на следующий элемент. В двусвязном списке в каждом элементе мы 
будем хранить указатель не только на следующий элемент, но и на предыдущий элемент (рисунок 3).
Это тоже зачем-нибудь нам может понадобиться. Это зависит от того, как мы собираемся использовать 
список - мы будем по нему перемещаться только слева направо или заодно и справа налево. 
Хотим ли мы иметь возможность вставлять элементы после произвольного или перед произвольным. 
На рисунке 3 показано схематичное обозначение двусвязного списка, а также голова списка (Head) и хвост списка (Tail). 
Сверху идут указатели на следующие элементы, снизу идут указатели на предыдущие элементы. То есть в данной ситуации 
каждый элемент нашего списка - это простенькая структура, которая хранит три поля: данные, указатель на следующий 
элемент и указатель на предыдущий элемент. В частности у самого последнего элемента нашего списка указатель на 
следующий элемент - нулевой, а у первого элемента указатель на предыдущий элемент нулевой.</p>
<img src="/images/lists/image3.svg" alt="Двусвязный список" />
<p>Рисунок 3 - Двусвязный список</p>
</div>
<h2>Операции со списками</h2>
<div align="justify">
<p>
Основными операциями, такие же как и для массивов, являются вставка и удаление. Рассмотрим отдельно вставку в начало 
списка, в конец списка и в произвольное место, опять будем называть его - серединой. Конечно же на самом деле 
мы хотим ещё что-нибудь знать о нашей структуре данных, например, пустая она или нет. Это можно сделать за 
константное время. Достаточно просто проверить нулевой ли элемент head или нет.
Мы можем захотеть перебрать все элементы списка и найти какой-нибудь, например, 
проверить есть ли ключ в нашей структуре данных или нет. Для списка это занимает 
линейное время. В худшем случае это будет работать за время О(<em>n</em>).</p>
</div>
<div align="justify">
<p>
Вернемся к вставке и удалению. В конец вставлять что-нибудь довольно просто при условии, что у нас есть ссылка 
на конец, т. е. указатель на последний элемент (мы поддерживаем указатель tail). Тогда мы за О(<em>1</em>) 
можем вставить элемент в конец. Создаём новый элемент c данными, пусть его ключ будет равен девять (рисунок 4, а). 
Дальше мы должны изменить указатель последнего элемента так, чтобы он указывал на наш новый 
элемент. У элемента девять указатель на следующий элемент нулевой. Ну и последнее, что нам надо сделать это надо
обновить указатель на tail. То есть теперь новый элемент стал самым последним (рисунок 4, б).</p>
<img src="/images/lists/image4.svg" alt="Вставка в конец" />
<p>Рисунок 4 - Вставка в конец</p>
</div>
<div align="justify">
<p>
Давайте поговорим про вставку в начало. Вставка в начало делается на самом деле также просто, за О(<em>1</em>). 
Мы знаем указатель на первый элемент списка. Предположим нам надо вставить элемент с данными, например, пять. 
Мы создаём этот элемент (рисунок 5, а). Дальше меняем указатель этого элемента на head, бывшую голову. 
Затем надо просто отметить, что теперь наш указатель на голову списка указывает на новый элемент (рисунок 5, б).</p>
<img src="/images/lists/image5.svg" alt="Вставка в начало" />
<p>Рисунок 5 - Вставка в начало</p>
</div>
<div align="justify">
<p>
При вставке в середину придётся оговариваться, что мы имеем в виду, когда вставляем в середину.
В отличие от массива, когда у нас есть доступ по индексу, в списке никакого доступа по индексу у нас нет. 
Эти элементы разбросаны где-то в памяти, то есть по списку мы можем просто перемещаться в линейном порядке. 
По односвязному мы можем идти слева направо, по двусвязному можем идти в любом из двух направлений. 
Соответственно под вставкой в середину можно понимать две вещи. Вставка после какого-нибудь элемента, который нам дан, 
итератором или указателем, или до. Вставить после какого-нибудь элемента несложно. 
Допустим нам надо осуществить вставку после элемента, нам дали указатель на элемент два и просят вставить 
новый элемент после него. Давайте, во-первых, этот новый элемент создадим. Создадим его где-то в памяти с 
ключом три. Нам надо его вставить после элемента два. То есть надо, чтобы после элемента два шёл элемент три, 
после элемента три шёл элемент семь. Указатель next из элемента два должны необходимо перекинуть на третий, а 
указатель из третьего мы должны перекинуть на седьмой. Получился наш новый список (рисунок 6). Делается это тоже за О(<em>1</em>).
</p>
<img src="/images/lists/image6.svg" alt="Вставка после указанного элемента" />
<p>Рисунок 6 - Вставка после указанного элемента</p>
<p>
С другой стороны, предположим теперь, что нам надо что-то вставить перед элементом с ключом два, то есть между элементами с ключами один и два. 
В такой ситуации нам надо будет менять указатель <code>next</code>, который идёт из элемента с ключом один.
Но к этому элементу у нас доступа сейчас нет. Сейчас известен только указатель на элемент два. И мы по этому элементу 
два его предыдущий получить никак не можем. Тогда вариантов два: либо мы должны, когда нам дали этот указатель, 
идти от головы списка и ждать пока мы не наткнемся на элемент, у которого следующим будет данный нам элемент. 
Тогда придется потратить линейное время O(<em>n</em>) на то, чтобы просто найти предыдущий элемент. 
Либо же мы можем поддерживать двусвязный список. В двусвязном списке, как Вы помните, нам надо хранить указатели 
на все предыдущие элементы. Соответственно, если такие указатели есть, тогда эта самая вставка перед нужным 
элементом происходит просто. Поскольку из элемента с ключом два, мы перейдя по указателю prev получаем его 
предыдущий элемент. Соответственно, чтобы вставить новый элемент нам надо где-то в памяти создать новый элемент (рисунок 7, а). 
Пусть у него тоже будет ключ семь, ничего что он повторяется. После чего надо аккуратно прописать все ссылки. 
Теперь предыдущий перед двойкой элемент - это семерка, а предыдущий перед семеркой - это единица (рисунок 7, б). Мы
восстановили структуру списка и действительно вставили элемент перед вторым. Соответственно, чтобы сделать это 
за О(<em>1</em>), нам понадобилась двусвязность. Без двусвязности просто чтобы найти предыдущий элемент нам придется тратить 
время О(<em>n</em>), то есть нам придётся перемещаться по списку, пока мы не найдем предыдущий элемент, находящийся
перед тем, на который у нас есть указатель.</div>
<img src="/images/lists/image7.svg" alt="Вставка до указанного элемента" />
<p>Рисунок 7 - Вставка до указанного элемента</p>
<div align="justify">
<p>
Перейдём к удалению. Удаление из начала осуществляется легко. Пусть нас попросили удалить первый элемент списка. 
Давайте просто забудем про этот элемент и будем считать теперь что голова списка, - это теперь элемент четыре. 
Соответственно надо не забыть его указатель previous, если список двусвязный, сделать нулевым (рисунок 6). Время работы - О(<em>1</em>).
</p>
<img src="/images/lists/image8.svg" alt="Удаление из начала" />
<p>Рисунок 8 - Удаление из начала</p>
<p>
С конца удаление происходит аналогично. Если у нас двусвязный список и если хранится указатель на конец, тогда это всё
делается за О(<em>1</em>). Находим предпоследний элемент, используя указатель prev последнего, и присваиваем его 
указателю next значение null (рисунок 7).</p>
<img src="/images/lists/image9.svg" alt="Удаление из конца" />
<p>Рисунок 9 - Удаление из конца</p>
</div>
<div align="justify">
При удалении из середины также полезна двусвязность. Пусть дан указатель на элемент семь и необходимо удалить его (рисунок 8).
Меняем указатели, чтобы следующий для тройки ссылался на девять, а предыдущий для ключа девять — на тройку. 
К счастью, из элемента с ключом семь мы можем узнать кто идёт перед ним и кто идёт за ним. 
То есть время работы тоже О(<em>1</em>), если у нас есть двусвязность.
</div>
<img src="/images/lists/image10.svg" alt="Удаление из середины" />
<p>Рисунок 10 - Удаление из середины</p>
<div align="justify">
<p>
Делать список односвязным или двусвязным, хранить в нём указатель на конец списка или нет, зависит от того какие 
именно операции нам придется производить со списком. Если хранить указатель на конец (хвост) списка и поддерживать 
список двусвязным, то как мы видим все операции можно делать за О(<em>1</em>): вставку в конец, в начало и в 
произвольное место. Какие именно нам понадобятся операции зависит от конкретного применения.</p>
<p>Вооружившись этими знаниями о массивах и списках, в следующей части рассмотрим возможные реализации и описание 
таких структур данных как очередь и стек.</p></div>


|          |     вставка    |    удаление    |
|:--------:|:--------------:|:--------------:|
|  начало  |   O(1)         |   O(1)         |
|   конец  |   O(1)         |   O(n) (односв), O(1) (двусв) |
| середина |   O(n) (односв), O(1) (двусв) |   O(n) (односв), O(1) (двусв) |