<h1>Деревья</h1>
<div align="justify">
<p>
Начнём с определения дерева на языке теории графов или дискретной математики. Дерево - это просто неориентированный 
граф, который с одной стороны является связным, с другой стороны не содержит циклов. Здесь слева приведен пример такого
простого дерева на семи вершинах (рисунок 1). Снизу также приведены два простых, но важных свойства. Первое свойство гласит, 
что если в дереве есть <em>n</em> вершин, то в нём обязательно будет <em>n</em>-1 ребер. Второе естественное, но в то же время важное 
свойство заключается в том, что в дереве между любыми двумя вершинами существует только один путь. Итак это 
математическое определение дерева. С помощью деревьев мы собираемся представлять какие-то данные и в большинстве 
случаев будем использовать корневые деревья. С точки зрения дискретной математики или теории графов, корневое дерево - 
это просто обычное дерево, в котором одна из вершин объявлена или помечена как корень. Например, здесь справа на рисунке 1 приведен 
пример того же самого дерева, которое мы взяли и потянули за вершину F и просто 
по-другому его изобразили. В этот момент мы объявили вершину F корнем этого дерева. Дерево при этом у нас разложилось 
по уровням. И это важное свойство корневого дерева, которое мы на самом деле будем использовать, представляя различные
данные на практике. Когда мы получили корневое дерево у нас также возникла следующее естественная генеалогическая 
терминология. Итак F - это корень, у него есть два сына E и G. В общем случае когда есть вершина, а под ней 
непосредственно находятся какие-то другие вершины, мы все эти вершины называем сыновьями этой вершины, а саму эту 
вершину родителем этих всех вершин. И это определение вот таких вот родственных связей (сын-родитель, родитель-сын)
естественным образом обобщается на предков и потомков. Итак именно корневые деревья обычно используются на практике 
для представления данных. И применений корневых деревьев миллионы. Например, мы можем представлять некоторые 
иерархические связи, например, связи подчинения. Для людей в компании можно сказать, что директор - это 
корень дерева, у него есть непосредственные заместители, у каждого заместителя в подчинении есть какие-то люди, то 
есть здесь связь иерархическая, это такая связь подчинения или связь зависимостей. Бывает генеалогическое дерево, 
когда какой-то элемент дерева является родителем другого элемента в дереве. Бывают синтаксические деревья разбора 
арифметического выражения, кода на языке программирования или предложения на естественном языке и так далее. Применений 
очень много.</p>
<div align="center">
<img src="/images/trees/image1.svg" alt="примеры деревьев" />
</div>
<p>Рисунок 1 - Примеры деревьев</p>
</div>
<div align="justify">
<p>
Поговорим о том как представлять деревья в компьютере и в программе. Мы рассмотрим несколько 
способов. Тот способ, который нужен конкретному приложению, зависит от того, что мы собираемся хранить в дереве и от 
того как именно мы собираемся это дерево обрабатывать или обходить. Один из самых простых, но с то же время компактных 
способов, заключается в следующем. Для каждой вершины давайте просто хранить, например, указатель или ссылку на её 
родителя. Здесь на рисунке 2, а предполагается, что у нас просто все вершины пронумерованы числами от одного до девяти. 
На самом деле никакие данные мы здесь не храним. Мы можем их где-то хранить в соседнем массиве или в дополнительной 
структуре данных, то есть здесь мы просто предполагаем, что вершины - это числа от одного до девяти. Чтобы
определить дерево, мы просто для каждой вершины должны задать её родителя. Давайте 
посмотрим на рисунок 2, б. Здесь мы видим, что в первой ячейке массива лежит число шесть - это означает, что вершина 
шесть является родителем вершины один. В ячейке три лежит число три. Так мы обозначили, что у вершины три нет родителя. 
Можно было бы также положить туда какое-то значение по умолчанию, например, минус один. Таким образом, три 
является корнем. Итак этот массив задаёт дерево. Это представление очень компактное. Например, если вам нужно 
записать дерево в файл, тогда это естественный способ сделать это. С другой стороны, всё что такое представление 
нам позволяет - это по вершине найти её родителя. Если по вершине в какой-то момент понадобится найти всех её 
сыновей, тогда необходимо какое-то другое представление, которое можно также построить для этого графа.</p>
<div align="center">
<img src="/images/trees/image2.svg" alt="Представление дерева в виде списка родителей" />
</div>
<p>Рисунок 2 - Представление дерева в виде списка родителей</p>
</div>
<div align="justify">
<p>
Одно из таких представлений — довольно естественное, для каждой вершины давайте запомним список её детей. На рисунке 3 показано 
то же самое дерево и структура, которая в теории графов известна как список смежности. Мы храним массив 
размера девять, но каждая ячейка - этого массива это на самом деле. Например, в ячейке три мы храним всех детей вершины 
три, то есть в этом вертикальном списке хранятся элементы, а в каждом горизонтальном элементе хранится индекс 
соответствующей вершины. Вот у вершины три есть два сына - шесть и девять. 
Соответственно, например, если в какой-то момент нам по вершине шесть понадобится получить доступ ко всем её детям, 
то мы просто пойдем в шестую ячейку нашего массива и оттуда всех детей прочитаем. Из рисунка мы видим там пять, один и 
четыре. Довольно удобно. Если при этом по вершине нужно уметь находить её родителя, то можно заодно хранить предыдущее 
представление, то есть список всех родителей.</p>
<div align="center">
<img src="/images/trees/image3.svg" alt="Представление дерева в виде списка детей" />
</div>
<p>Рисунок 3 - Представление дерева в виде списка детей</p>
</div>
<div align="justify">
<p>
Следующее представление уже более общее. Здесь не предполагается, что у нас все вершины пронумерованы от единицы 
до количества вершин. Считается, что просто все вершины в нашем дереве, во-первых, хранят какие-то данные, и мы 
хотим по вершине иметь доступ и к родителю и ко всем её сыновьям. Тогда можно для каждой вершины завести такую 
структуру данных, в которой одно поле отвечает за данные, второе - за родителя, третье - за сыновей. Поскольку 
сыновей может быть много, то в третьем поле может хранится массив или список, в который мы будем записывать сыновей или если
мы знаем, что дерево бинарное, тогда можно просто хранить не одно третье поле, а третье и четвертое поле, то есть 
левого и правого сына (если сыновей всё время не больше, чем два). Тогда дерево (математический объект), которое на 
рисунке 4 нарисовано слева, в памяти компьютера будет представлено как показано справа. Каждая вершина - это такая 
структура данных и все они имеют один и тот же тип. И состоит эта структура данных из нескольких полей. Первое поле 
отвечает за некоторые данные, здесь это просто буква. Второе поле - это ссылка на такую же структуру данных, то 
есть на родителя. Третье поле содержит ссылки на всех сыновей. На рисунке не показано как именно мы храним это самое 
третье поле. Это может быть список, массив или две ссылки на левого и правого сына, если дерево бинарное.
</p>
<div align="center">
<img src="/images/trees/image4.svg" alt="Представление дерева в виде вершины, ссылки на родителя и детей" />
</div>
<p>Рисунок 4 - Представление дерева в виде вершины, ссылки на родителя и детей</p>
</div>
<div align="justify">
То какое именно представление Вам понадобится на практике, зависит от того что именно вы собираетесь хранить в вашем дереве и 
как именно Вы собираетесь Ваше дерево обрабатывать. Алгоритмы обработки деревьев и вычисления некоторой информации по 
деревьям, как правило, являются рекурсивными. И связано это с тем, что корневые деревья на самом деле и определять так 
довольно естественно рекурсивно или рекуррентно. Давайте определим корневое дерево следующим образом: во-первых 
корневое дерево может быть пустым, то есть не содержать никаких вершин. Другими словами пустое дерево - это тоже 
корневое дерево. Если оно не пусто - значит у него есть корень. А у этого корня есть несколько сыновей каждый из 
которых является корнем тоже какого-то поддерева, возможно пустого, возможно нет. Это такое 
рекуррентное определение дерева: корень плюс несколько поддеревьев подвешенных к этому корню. Такое определение 
корневого дерева в голове для того, чтобы иногда очень просто написать какой-нибудь рекурсивный алгоритм для вычисления
чего-нибудь по дереву. Предположим, например, что нам нужно посчитать высоту дерева. Высота - это максимальное 
количество вершин на пути от корня к какому-нибудь листу. Давайте попробуем переформулировать это определение. 
Итак нам надо встать в корень и куда-то пойти до листа причём так, чтобы количество вершин на этом пути было как можно 
больше, то есть чтобы этот лист, который мы ищем был самым глубоким. Давайте подумаем как найти этот самый глубокий лист. 
От корня мы можем пойти либо в первого, либо во второго либо в третьего сына. Мы не знаем в каком из них будет самый
глубокий лист, но мы можем рекурсивно это проверить. Мы можем для каждого из трёх сыновей вычислить высоту 
рекурсивно, а после этого просто к максимальному из них прибавить единицу и тем самым мы получим высоту нашего 
исходного дерева. Это даёт нам следующий компактный рекурсивный алгоритм. Процедура <code>Height()</code>, она получает на вход 
вершину r (рисунок 5), у меня слева здесь с помощью буквы r обозначен корень, но в эту процедуру можно на самом деле передать 
любую вершину нашего дерева и то что она вернёт - это будет высота соответствующего поддерева с 
корнем в вершине r. Итак первое что мы делаем мы заводим переменную height и говорим что она равна 1. Единица 
соответствует просто высоте дерева состоящего только из вершины r, мы пока что не знаем есть ли у вершины r вообще 
хоть какие-то сыновья, поэтому заранее говорим, что высота равна 1. Если там будут какие-то ещё сыновья, то мы в них 
перейдём, посчитаем высоту и может быть её увеличим. Дальше перебираем всех сыновей вершины r. Для 
каждого из них вычисляем высоту рекурсивно. Делаем вызов height от c, дальше прибавляем к этому единицу и смотрим 
не получилось ли больше, чем наша текущая высота. Если да, тогда обновляем высоту. В конце просто эту высоту 
выдаём. С помощью четырех строчек кода мы легко посчитали высоту дерева. То есть легко нашли максимальную длину 
пути, максимальное число вершин на пути от корня к листу. Ещё один пример такого очень естественной 
задачи по дереву - это обход дерева, ну в частности печать все вершин нашего дерева, каждую по одному разу. Заведём 
процедуру <code>PrintTree()</code>, которая напечатает все вершины из дерева с корнем в вершине r. Первым делом печатаем 
саму вершину. Предполагаем, что в вершине есть какие-то данные и мы их просто печатаем таким 
вот вызовом <code>print(r)</code>. Дальше мы перебираем просто всех детей этой вершины и для каждого из этих детей вызываем 
рекурсивно нашу процедуру. При это напечатаются все вершины из первого поддерева, из второго поддерева и из 
третьего поддерева. Итого пользуясь рекуррентным определением нашего дерева мы напечатали корень, а потом рекурсивно 
все его поддеревья. Такой трюк работает для многих деревьев и его полезно держать в голове.
<div align="center">
<img src="/images/trees/image5.svg" alt="Рекуррентное определение дерева и рекурсивный алгоритм вычисления высоты" />
</div>
<p>Рисунок 5 - Рекуррентное определение дерева и рекурсивный алгоритм вычисления высоты</p>
</div>
<pre>
Height(r)
    height <- 1
    for all children c of r:
        height <- max(height, 1+height(c))
    return height
</pre>

<pre>
PrintTree(r):
    print(r)
    for all children c of r:
        PrintTree(c)
</pre>