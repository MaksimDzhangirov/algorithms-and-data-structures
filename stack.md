<h1>Стек</h1>
<div align="justify">
Следующая простая, но важная структура данных, которую мы рассмотрим, называется стек. 
И скорее всего она Вам уже знакома. В отличие от предыдущих двух структур данных, стек - это абстрактная структура 
данных, интерфейс или тип. Задаётся он просто операциями, то есть методами, которые должны удовлетворять следующим
свойствам. Методы называются <code>Push()</code> и <code>Pop()</code> (основные), т. е. на стек мы можем положить что-то на вершину и можем снять 
с неё. При этом, когда мы снимаем что-то со стека, то сниматься должен последний положенный на него элемент.
Представить его можно как стакан или как стопку (рисунок 1), в который мы складываем наши элементы и вытащить из 
стакана мы можем только то, что лежит у него на верхушке.</div>
<img src="/images/arrays/image1.png" alt="пример стека" />
<p>Рисунок 1 - Пример стека</p>

<p>Распишем методы более формально:</p>
<ol>
<li><code>Push()</code> - получает на вход там ключ или элемент и кладёт его на верхушку стека.</li>
<li><code>Top()</code> - просто определяет, что лежит на верхушке.</li>
<li><code>Pop()</code> - снимает элемент с верхушки, то есть изменяет стек.</li>
<li><code>Empty()</code> или <code>IsEmpty()</code> - определяет стек пустой или нет.</li>
<li><code>Size()</code> - определяет текущий размер стека.</li>
</ol>
<div align="justify">
Стек — это структура данных типа LIFO, то есть Last In First Out (первым извлекается из него элемент, который 
был положен на стек последним). Классическая задача, в которой стек оказывается полезным — это проверка правильности
расстановки скобок. Пусть нам дана некоторая последовательность, которая состоит, например, только из скобок. Вообще 
это может быть просто код на языке программирования. Мы из него выкидываем все символы кроме скобок и хотим 
проверить правильно ли расставлены скобки. Что значит правильно? Это значит, что для каждой открывающейся скобки 
есть соответствующая ей закрывающаяся. Здесь приведено несколько примеров и мы используем два типа 
скобок: круглые и квадратные. В целом эта задача осмыслена также и для одного типа скобок, например, когда у нас 
есть только круглые скобки или наоборот, когда у нас типов скобок больше, например, круглые, квадратные и фигурные. 
Первые два примера (рисунок 2 (а), (б)) - правильные. Ниже (рисунок 2 (в), (г), (д)) показаны три примера 
неправильной расстановки скобок, заодно иллюстрирующие те места, где что-то может пойти не так, когда мы 
расставляем скобки. В первом случае последовательность начинается с закрывающейся скобки. Такого конечно не 
может быть, она ничего не закрывает, перед ней нет соответствующей ей открывающейся скобки. Во втором примере мы видим,
что четвертый символ в этой строке это квадратная закрывающаяся скобка, но перед ней нет соответствующей квадратной 
открывающейся скобки. Она закрывает как бы первый символ этой строки - открывающуюся скобку, но она другого типа 
(круглая). В последнем примере у нас сначала идёт открывающаяся скобка, потом пара правильно расставленных квадратных 
скобок, а потом ничего. Соответственно первая же открывающаяся круглая скобка не закрыта, поэтому это тоже неправильный
пример.
</div>
<img src="/images/arrays/image2.png" alt="Последовательность скобок" />
<p>Рисунок 2 - Последовательность скобок</p>
<div align="justify">
Давайте покажем как можно использовать стек, чтобы решить эту задачу. 
Сначала разберем алгоритм на примерах, а потом приведём псевдокод. 
Итак мы могли бы действовать так. Изобразим стек схематично как показано на рисунке 3 (а) и будем рассматривать 
последовательность на рисунке 2 (а). Мы считаем эту строку слева направо, видим открывающуюся скобку и кладём её 
на стек (рисунок 3 (б)). Дальше мы читаем следующий элемент - закрывающаяся круглая скобка. 
Закрывающиеся скобки никогда на стек класть не будем, но когда их встречаем, мы понимаем, что она что-то должна 
закрывать и это что-то должно лежать на вершине стека. Поэтому мы в этот момент проверяем верно лежит ли там
соответствующая ей открывающаяся скобка, т. е. того же типа. В нашем случае да - на вершине сейчас лежит 
открывающаяся скобка, она круглая, поэтому эти две скобки друг друга просто взаимно уничтожают. 
Происходит следующее - теперь наш стек выглядит, как показано на рисунке 3 (в), он пустой. 
Далее считываем следующий элемент (открывающаяся квадратная скобка) - стек имеет вид как на рисунке 3 (г).
Следующий символ - закрывающаяся квадратная, скобки друг друга опять сократили (рисунок 3 (д)).
Дальше мы прочитали открывающуюся круглую и открывающуюся квадратную. Положили их тоже на стек (рисунок 3 (е)). Дальше видим 
закрывающуюся, которая сокращается с той, что лежит на вершине (рисунок 3 (ж)). Наконец, считываем вот эту вот закрывающуюся круглую, 
и она тоже сокращается с той, что лежит на стеке (рисунок 3 (з)). 
Итак строка закончилась, стек пустой, следовательно, скобки расставлены правильно и это действительно так.
Перейдём к неправильным примерам (рисунок 2 (в)). 
Считываем первый же символ. Видим, что это закрывающаяся скобка. Попытаемся в стеке найти соответствующую ей открывающуюся 
скобку, но стек пуст. Тут же можно сделать вывод, что скобки расставлены неправильно. Во втором примере на вершине 
стека будет лежать открывающаяся круглая скобка, которую мы попытаемся сократить 
квадратной, чего сделать нельзя. В третьем примере последовательность закончится, но стек при этом не оказался 
пустым. Это означает, что остались не закрытые скобки. Тогда мы тоже говорим, что скобки расставлены не правильно.
</div>
<img src="/images/arrays/image3.png" alt="Состояние стека для последовательности на рисунке 2(а)" />
<p>Рисунок 3 - Состояние стека для последовательности на рисунке 2(а)</p>
<p>Приведём псевдокод.</p>

<pre>
func IsBalanced(str):
    Stack stack
    for char in str:
        if char in ('(', '['):
            stack.Push(char)
        else:
            if stack.Empty():
                return False
            top <- stack.Pop()
            if (top == '[' and char != ']') or
               (top == '(' and char != ')'):
                   return False
    return stack.Empty()
</pre>
<div align="justify">
<p>
Рассмотрим метод, который называется <code>IsBalanced</code>. Ему на вход подаётся строка. Давайте сразу считать, что в этой строке у
нас все символы это скобки двух типов. Все другие символы мы заранее оттуда удалили. Хотя другие символы мы могли бы 
просто пропускать. Первое, что мы делаем — создаём стек. Дальше последовательно читаем строку в цикле <code>for</code>. Если скобка
открывающаяся, то просто кладём её на вершину стека. В противном случае скобка закрывающаяся. Давайте первым делом 
проверим не пуст ли случайно стек. Если пуст — сразу делаем вывод — скобки расставлены не правильно, поскольку мы нашли
какую-то закрывающуюся скобку, у которой нет соответствующей открывающейся. В противном случае — если стек не пустой — 
давайте возьмём его верхушку и проверим, что соответствующий символ — это открывающаяся скобка причем того же типа. 
Если эта проверка не прошла — сразу говорим, скобки расставлены неверно.</p>
<p>
Наконец, если в конце остался пустой стек, тогда мы говорим, что скобки расставлены правильно.</p>
<p>Как видно из этого псевдокода - True мы возвращаем только в ситуации, когда нигде по середине никаких проблем не
оказалось, то есть все закрывающиеся скобки, которые мы нашли, они что-то закрывали и когда в самом 
конце мы всё прочитали никаких открывающихся скобок не осталось. Таким образом, мы проверили все
условия, при которых что-то могло пойти не так, и если ни одно из них не выполнилось, тогда в конце можно сказать, что скобки 
расставлены правильно.</p>
</div>
<div align="justify">
Давайте теперь поговорим о том как можно было бы реализовывать стек. Существует две очень естественные реализации. 
Можно стек реализовывать с помощью массива, а можно с помощью односвязного списка. Слева приведен пример очень 
простого стека, в котором лежат три элемента. Чтобы поддерживать все наши имеющиеся операции: <code>Push</code>, <code>Pop</code>, <code>Top</code>, <code>Empty</code>, 
можно завести массив. Массив будет фиксированного размера соответственно мы сможем поддерживать только стек ограниченного 
размера. Какого размера будет этот массив - столько максимум элементов мы сможем положить в наш стек. Мы заполняем 
этот массив слева направо и когда нам надо извлечь последний элемент, мы просто возвращаем последний
элемент. Когда нам надо положить - мы добавляем его в конец. Делается это за О(<em>1</em>). Единственное ограничение 
в том, что нам надо заранее знать максимальное количество элементов, которое у нас будет в стеке. Даже если мы знаем 
это максимальное количество, но оно какое-то очень большое, а работать приходится с маленьким количеством, то 
потенциально может случиться так, что мы выделим огромный кусок памяти ради того, чтобы поработать 
небольшим количеством элементов. В таком случае возможно осмысленнее реализовывать стек с помощью 
односвязного списка. Голова списка (Head) будет соответствовать вершине стека. Соответственно если нам 
надо добавить что-то, то в начало списка как вы помните добавлять довольно просто. Пусть понадобилось 
положить в стек новый элемент семь. Мы знаем указатель на начало списка, поэтому мы просто теперь из нашего нового 
элемента семь поставим указатель на следующий, чтобы он указывал туда, куда раньше указывала голова. Ну а после этого 
скажем, что головой теперь является элемент семь. Извлекать также просто. Просто убираем семерку и 
говорим - теперь голова это тройка. Опять таки работает это за О(<em>1</em>). То есть все операции будут работать за
О(<em>1</em>). Не сложно сделать так, чтобы операция, которая возвращает размер стека тоже работала за константное
время. Просто его надо поддерживать тогда и каждый раз когда мы удаляем что-то из стека уменьшать на единицу, а 
когда кладём - увеличиваем на единицу.</div>

<h2>Стек с поддержкой минимума (максимума)</h2>

<div align="justify">
Несложно модифицировать стек так, чтобы он поддерживал операцию возвращения максимума в текущем стеке.
Предположим, для простоты, что в стеке хранятся числа, но помимо всех операций, которые уже перечислены, мы хотим 
ещё за константное время отвечать на вопрос какое из них минимальное (максимальное). 
Предположим у нас уже есть готовая реализация стека. Тогда можно написать такую обертку, внутри которой будут лежать на
самом деле два стека. Первый — это стек, где хранятся элементы, а второй — куда мы просто в каждый момент времени, когда
добавляем элемент, записываем текущее минимальное значение. Предположим, например, у нас такой слева стек из наших 
элементов, а справа на рисунке 4 - это стек из текущих минимумов.</div>
<img src="/images/arrays/image4.png" alt="Стек с поддержкой минимума" />
<p>Рисунок 4 - Стек с поддержкой минимума</p>
<div align="justify">
Предположим нам понадобилось положить новый элемент. Мы добавляем элемент пять сюда, но мы понимаем, что нам что-то надо 
сделать также со стеком минимумов. Текущий минимум найти легко. Мы знаем, что до добавления пятерки минимумом была 
единица. Знаем мы это, потому что можем вызвать <code>Top()</code> для этого стека с минимумом. Мы видим, что это меньше, чем 
пятерка, поэтому текущий минимум во всё нашем стеке по-прежнему единица. Когда что-то удаляется, мы просто банально 
берём и удаляем элемент из двух стеков. Таким образом мы каждый раз поддерживаем минимум. И поддерживается он как 
видно за константное время. Такой несложной модификацией (за счет удвоения потребление памяти) возможно отвечать на
запросы минимума за константное время. Существуют задачи, где это окажется для нас существенным.
</div>